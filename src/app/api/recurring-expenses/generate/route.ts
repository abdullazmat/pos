import { NextResponse } from "next/server";
import dbConnect from "@/lib/db/connect";
import RecurringExpense from "@/lib/models/RecurringExpense";
import Expense from "@/lib/models/Expense";
import { verifyToken } from "@/lib/utils/jwt";

// POST - Generate pending recurring expenses for today
// This endpoint checks all active recurring expenses and generates
// actual Expense records for those that are due.
// It can be called manually or via a cron job.
export async function POST(request: Request) {
  try {
    const token = request.headers.get("authorization")?.split(" ")[1];
    if (!token) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const decoded = verifyToken(token);
    if (!decoded) {
      return NextResponse.json({ error: "Invalid token" }, { status: 401 });
    }

    await dbConnect();

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Find all active recurring expenses for this business
    const recurringExpenses = await RecurringExpense.find({
      business: decoded.businessId,
      active: true,
      startDate: { $lte: today },
      $or: [{ endDate: null }, { endDate: { $gte: today } }],
    });

    const generated: any[] = [];
    const pending: any[] = [];

    for (const recurring of recurringExpenses) {
      const shouldGenerate = checkIfDue(recurring, today);

      if (!shouldGenerate) continue;

      if (recurring.requiresConfirmation) {
        // Add to pending list for user confirmation
        pending.push({
          _id: recurring._id,
          description: recurring.description,
          category: recurring.category,
          baseAmount: recurring.baseAmount,
          frequency: recurring.frequency,
          paymentMethod: recurring.paymentMethod,
          notes: recurring.notes,
        });
      } else {
        // Auto-generate the expense
        const expense = await Expense.create({
          description: recurring.description,
          amount: recurring.baseAmount,
          category: recurring.category,
          paymentMethod: recurring.paymentMethod,
          notes: recurring.notes
            ? `[Auto] ${recurring.notes}`
            : `[Auto] Gasto recurrente`,
          date: today,
          source: "recurring",
          recurringExpenseId: recurring._id,
          supplier: recurring.supplier || null,
          business: decoded.businessId,
          user: decoded.userId,
        });

        // Update last generated date
        await RecurringExpense.findByIdAndUpdate(recurring._id, {
          lastGeneratedDate: today,
        });

        generated.push(expense);
      }
    }

    return NextResponse.json({
      generated,
      pending,
      summary: {
        totalChecked: recurringExpenses.length,
        autoGenerated: generated.length,
        pendingConfirmation: pending.length,
      },
    });
  } catch (error) {
    console.error("Generate recurring expenses error:", error);
    return NextResponse.json(
      { error: "Failed to generate recurring expenses" },
      { status: 500 },
    );
  }
}

// POST to /api/recurring-expenses/generate with action=confirm
// Confirms a pending recurring expense, optionally adjusting the amount
export async function PUT(request: Request) {
  try {
    const token = request.headers.get("authorization")?.split(" ")[1];
    if (!token) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const decoded = verifyToken(token);
    if (!decoded) {
      return NextResponse.json({ error: "Invalid token" }, { status: 401 });
    }

    const body = await request.json();
    const { recurringExpenseId, adjustedAmount } = body;

    if (!recurringExpenseId) {
      return NextResponse.json(
        { error: "Recurring expense ID is required" },
        { status: 400 },
      );
    }

    await dbConnect();

    const recurring = await RecurringExpense.findOne({
      _id: recurringExpenseId,
      business: decoded.businessId,
    });

    if (!recurring) {
      return NextResponse.json(
        { error: "Recurring expense not found" },
        { status: 404 },
      );
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const finalAmount =
      adjustedAmount !== undefined && adjustedAmount !== null
        ? parseFloat(adjustedAmount)
        : recurring.baseAmount;

    const expense = await Expense.create({
      description: recurring.description,
      amount: finalAmount,
      category: recurring.category,
      paymentMethod: recurring.paymentMethod,
      notes: recurring.notes
        ? `[Confirmado] ${recurring.notes}`
        : `[Confirmado] Gasto recurrente`,
      date: today,
      business: decoded.businessId,
      user: decoded.userId,
    });

    // Update last generated date
    await RecurringExpense.findByIdAndUpdate(recurring._id, {
      lastGeneratedDate: today,
    });

    return NextResponse.json({ expense });
  } catch (error) {
    console.error("Confirm recurring expense error:", error);
    return NextResponse.json(
      { error: "Failed to confirm recurring expense" },
      { status: 500 },
    );
  }
}

/**
 * Checks if a recurring expense is due for generation today.
 */
function checkIfDue(recurring: any, today: Date): boolean {
  const todayDay = today.getDate();
  const todayDayOfWeek = today.getDay(); // 0=Sun, 1=Mon, ...

  // If already generated today, skip
  if (recurring.lastGeneratedDate) {
    const lastGen = new Date(recurring.lastGeneratedDate);
    lastGen.setHours(0, 0, 0, 0);
    if (lastGen.getTime() === today.getTime()) {
      return false;
    }
  }

  switch (recurring.frequency) {
    case "monthly":
      // Generate on the execution day of each month
      // Handle months with fewer days (e.g., execution day 31 in Feb â†’ last day)
      const lastDayOfMonth = new Date(
        today.getFullYear(),
        today.getMonth() + 1,
        0,
      ).getDate();
      const effectiveDay = Math.min(recurring.executionDay, lastDayOfMonth);
      return todayDay === effectiveDay;

    case "weekly":
      // executionDay: 1=Monday, 2=Tuesday, ... 7=Sunday
      const mappedDay =
        recurring.executionDay === 7 ? 0 : recurring.executionDay;
      return todayDayOfWeek === mappedDay;

    case "biweekly":
      // Every 2 weeks from the start date, on the execution day of the week
      const mappedDayBw =
        recurring.executionDay === 7 ? 0 : recurring.executionDay;
      if (todayDayOfWeek !== mappedDayBw) return false;
      const startDate = new Date(recurring.startDate);
      startDate.setHours(0, 0, 0, 0);
      const diffTime = today.getTime() - startDate.getTime();
      const diffWeeks = Math.floor(diffTime / (7 * 24 * 60 * 60 * 1000));
      return diffWeeks % 2 === 0;

    case "annual":
      // Generate on execution day of the start month each year
      const startMonth = new Date(recurring.startDate).getMonth();
      if (today.getMonth() !== startMonth) return false;
      const lastDayAnnual = new Date(
        today.getFullYear(),
        today.getMonth() + 1,
        0,
      ).getDate();
      const effectiveDayAnnual = Math.min(
        recurring.executionDay,
        lastDayAnnual,
      );
      return todayDay === effectiveDayAnnual;

    default:
      return false;
  }
}
